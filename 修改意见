一、后端：建立日期索引 + 新增接口

1. 更新 app/api/cron-generate/route.ts

在成功生成 data 后，新增一行把日期写入排序索引（便于归档页读取）：

// ...
if (!data?.items || !Array.isArray(data.items)) throw new Error('模型输出缺少 items');
if (!data?.date) data.date = todayUTC;

// 存储
await redis.set('brief:latest', data);
await redis.set(`brief:${data.date}`, data);

// ✅ 新增：把日期加入有序集合，按时间排序（score=当天 00:00 的 UNIX 时间）
const ts = Math.floor(new Date(data.date + 'T00:00:00Z').getTime() / 1000);
await redis.zadd('brief:index', { score: ts, member: data.date });

return NextResponse.json({ ok: true, count: data.items.length, date: data.date });

这样我们就能用 ZREVRANGE brief:index 0 -1 拿到所有历史日期（倒序）。

2. 新增 app/api/dates/route.ts（返回日期列表，倒序）

// app/api/dates/route.ts
import { NextResponse } from 'next/server';
import { Redis } from '@upstash/redis';
export const runtime = 'edge';

const redis = new Redis({
  url: process.env.KV_REST_API_URL!,
  token: process.env.KV_REST_API_TOKEN!,
});

export async function GET() {
  // 最近 200 天，按需调整
  const dates = await redis.zrange<string[]>('brief:index', 0, 199, { rev: true });
  return NextResponse.json({ dates });
}

3. 新增 app/api/brief/[date]/route.ts（按日期取简报）

// app/api/brief/[date]/route.ts
import { NextResponse } from 'next/server';
import { Redis } from '@upstash/redis';
export const runtime = 'edge';

const redis = new Redis({
  url: process.env.KV_REST_API_URL!,
  token: process.env.KV_REST_API_TOKEN!,
});

export async function GET(_: Request, { params }: { params: { date: string } }) {
  const data = await redis.get(`brief:${params.date}`);
  return NextResponse.json(data ?? { date: params.date, headline: '', items: [] });
}


⸻

二、前端：带 LOGO 的筛选器 + 页脚小字说明

1. 修改首页 app/(site)/page.tsx
	•	加入产品元信息（名字 + 简洁 SVG LOGO）
	•	筛选器显示图标与名称
	•	使用说明挪到底部注脚（小字）

将你当前文件替换为这版（保留你之前的样式/功能，只在顶部筛选器与底部说明做了增强）：

'use client';

import { useEffect, useMemo, useState } from 'react';

type Item = {
  product: string;
  type: 'new'|'update'|'feedback'|'fix';
  summary: string;
  tags?: string[];
  sources?: {name:string; url:string}[];
  time?: string;
}
type Brief = { date: string; headline: string; items: Item[]; };

const PRODUCT_META: Record<string, { label: string; icon: JSX.Element }> = {
  OpenAI: { label: 'OpenAI', icon: <svg width="16" height="16" viewBox="0 0 24 24"><circle cx="12" cy="12" r="9" /></svg> },
  Anthropic: { label: 'Anthropic', icon: <svg width="16" height="16" viewBox="0 0 24 24"><rect x="5" y="5" width="14" height="14" rx="3" /></svg> },
  Google: { label: 'Google', icon: <svg width="16" height="16" viewBox="0 0 24 24"><path d="M12 3a9 9 0 1 0 9 9" /></svg> },
  Meta: { label: 'Meta', icon: <svg width="16" height="16" viewBox="0 0 24 24"><path d="M4 16c2-8 8-8 10 0 2-8 8-8 10 0" /></svg> },
  Mistral: { label: 'Mistral', icon: <svg width="16" height="16" viewBox="0 0 24 24"><path d="M3 12h18M6 8h12M6 16h12"/></svg> },
  xAI: { label: 'xAI', icon: <svg width="16" height="16" viewBox="0 0 24 24"><path d="M4 4l16 16M20 4L4 20"/></svg> },
  Microsoft: { label: 'Microsoft', icon: <svg width="16" height="16" viewBox="0 0 24 24"><path d="M4 4h8v8H4zM12 4h8v8h-8zM4 12h8v8H4zM12 12h8v8h-8z"/></svg> },
  '百度': { label: '百度', icon: <svg width="16" height="16" viewBox="0 0 24 24"><path d="M8 8a3 3 0 1 1 6 0M5 14h14"/></svg> },
  '阿里': { label: '阿里', icon: <svg width="16" height="16" viewBox="0 0 24 24"><path d="M4 12h16M12 4v16"/></svg> },
  '字节': { label: '字节', icon: <svg width="16" height="16" viewBox="0 0 24 24"><rect x="6" y="4" width="3" height="16"/><rect x="11" y="4" width="3" height="16"/><rect x="16" y="6" width="2" height="12"/></svg> },
  '讯飞': { label: '讯飞', icon: <svg width="16" height="16" viewBox="0 0 24 24"><path d="M6 6l12 12M18 6L6 18"/></svg> },
  'Kimi': { label: 'Kimi', icon: <svg width="16" height="16" viewBox="0 0 24 24"><circle cx="8" cy="10" r="2"/><circle cx="16" cy="10" r="2"/></svg> },
};

const styles = `/* ——保留你之前的整套样式—— */`;

function iconByType(t:string){ /* 保留你之前的函数 */ }
function colorByType(t:string){ /* 保留你之前的函数 */ }
function fmtDate(d:string){ const dt=new Date(d); const y=dt.getFullYear(); const m=String(dt.getMonth()+1).padStart(2,'0'); const day=String(dt.getDate()).padStart(2,'0'); const wd=['日','一','二','三','四','五','六'][dt.getDay()]; return `${y}年${m}月${day}日（周${wd}）`; }

export default function Page(){
  const [brief, setBrief] = useState<Brief|null>(null);
  const [themeLight, setThemeLight] = useState(false);
  const [filter, setFilter] = useState<string>('全部');

  useEffect(()=>{ fetch('/api/brief').then(r=>r.json()).then(setBrief); },[]);

  const products = useMemo(()=> brief ? Array.from(new Set(brief.items.map(i=>i.product))) : [], [brief]);
  const items = useMemo(()=>{
    if (!brief) return [];
    const all = brief.items;
    return filter==='全部'? all : all.filter(i=>i.product===filter);
  }, [brief, filter]);

  if (!brief) return <div style={{padding:20}}>加载中…</div>;

  const counts = brief.items.reduce((acc:any,it)=>{acc[it.type]=(acc[it.type]||0)+1; return acc;},{} as Record<string,number>);
  const total = brief.items.length;
  const allSources = new Map<string,string>();
  brief.items.forEach(it=> (it.sources||[]).forEach(s=> allSources.set(s.url, s.name)) );

  // 顶部导航：增加「归档」入口
  const Nav = () => (
    <div className="actions">
      <a className="btn" href="/archive">归档</a>
      <button className="btn" onClick={()=>setThemeLight(v=>!v)}>切换主题</button>
      <button className="btn" onClick={()=>{
        const lines = [`## ${fmtDate(brief.date)} AI 产品每日简报`, `**要点**：${brief.headline}`, '', ...brief.items.map(it=>`- **${it.product}** [${it.type.toUpperCase()}] ${it.summary}`)];
        navigator.clipboard.writeText(lines.join('\\n'));
      }}>复制为 Markdown</button>
    </div>
  );

  return (
    <div className={themeLight ? 'light' : ''}>
      <style dangerouslySetInnerHTML={{__html: styles}} />
      <div className="wrap">
        <header>
          <div className="brand">
            <div className="logo" aria-hidden="true"></div>
            <div>
              <div className="title">AI 产品每日简报</div>
              <div className="subtitle"><span className="date">{fmtDate(brief.date||new Date().toISOString())}</span> · 自动生成 · 科技感样式</div>
            </div>
          </div>
          <Nav />
        </header>

        <section className="hero">
          <div>
            <h1>今日要点 · <span>{brief.headline || '—'}</span></h1>
            {/* ——这里去掉那句长文本，换成筛选器 —— */}
            <div className="kpis" style={{marginTop:0}}>
              {[{n: total, t:'今日条目'},{n: counts.new||0, t:'新发布'},{n: counts.update||0, t:'功能更新'},{n: counts.feedback||0, t:'反馈'},{n: counts.fix||0, t:'修复'}]
                .map((k,i)=>(<div className="kpi" key={i}><div className="n">{k.n}</div><div className="t">{k.t}</div></div>))}
            </div>
          </div>
          <div className="card" style={{padding:'14px'}}>
            {/* ✅ 带 LOGO 的筛选器 */}
            <div className="filterbar">
              {['全部', ...products].map(p=> {
                const meta = PRODUCT_META[p] || { label: p, icon: <svg width="16" height="16"><circle cx="8" cy="8" r="6"/></svg> };
                return (
                  <button key={p} className={`pill ${filter===p?'active':''}`} onClick={()=>setFilter(p)} data-prod={p} style={{display:'inline-flex',alignItems:'center',gap:8}}>
                    <span style={{display:'grid',placeItems:'center'}}>{meta.icon}</span>
                    <span>{meta.label}</span>
                  </button>
                )
              })}
            </div>
            <div className="divider"></div>
            <div className="tags">
              <span className="tag">NEW 新发布</span>
              <span className="tag">UPDATE 功能更新</span>
              <span className="tag">FEEDBACK 市场/用户反馈</span>
              <span className="tag">FIX 修复与回滚</span>
            </div>
          </div>
        </section>

        {/* 列表 */}
        <section className="grid">
          {/* ……保留你的列表与来源渲染逻辑 …… */}
        </section>

        {/* ✅ 页脚注脚（很小的字） */}
        <div className="footer" style={{fontSize:11, opacity:.7}}>
          注：本页面自动汇总公开来源的更新信息，用于学习与研究，不构成任何商业承诺或投资建议。
        </div>
      </div>
    </div>
  );
}

上面的 PRODUCT_META 用了简洁 SVG 作占位 LOGO。你想换成品牌矢量图标也行（把 SVG 换成你自己的）。

⸻

三、归档页：查看全部日期、按日进入详情

1. 新建 app/archive/page.tsx

'use client';
import { useEffect, useState } from 'react';

export default function ArchivePage(){
  const [dates, setDates] = useState<string[]>([]);
  useEffect(()=>{ fetch('/api/dates').then(r=>r.json()).then(d=>setDates(d.dates||[])); },[]);
  return (
    <div style={{maxWidth:900, margin:'40px auto', padding:'0 16px'}}>
      <h1 style={{margin:'0 0 12px'}}>简报归档</h1>
      <div style={{opacity:.7, fontSize:14, marginBottom:16}}>从最近到最早 · 点击进入某天</div>
      <div style={{display:'grid', gridTemplateColumns:'repeat(auto-fill,minmax(220px,1fr))', gap:12}}>
        {dates.map(d=>(
          <a key={d} href={`/brief/${d}`} style={{border:'1px solid rgba(255,255,255,.12)', padding:'14px', borderRadius:12, textDecoration:'none', color:'inherit'}}>
            <div style={{fontWeight:700}}>{d}</div>
            <div style={{opacity:.7, fontSize:12}}>查看当日更新 →</div>
          </a>
        ))}
      </div>
    </div>
  );
}

2. 新建 app/brief/[date]/page.tsx

'use client';
import { useEffect, useState } from 'react';

export default function BriefByDate({ params }: { params: { date: string } }){
  const { date } = params;
  const [data, setData] = useState<any>(null);
  useEffect(()=>{ fetch(`/api/brief/${date}`).then(r=>r.json()).then(setData); },[date]);

  if (!data) return <div style={{padding:20}}>加载中…</div>;

  return (
    <div style={{maxWidth:1100, margin:'40px auto', padding:'0 16px'}}>
      <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
        <h1 style={{margin:0}}>简报 · {date}</h1>
        <a href="/archive" style={{opacity:.8}}>返回归档</a>
      </div>
      <div style={{marginTop:12, opacity:.75}}>{data.headline || '—'}</div>
      <div style={{marginTop:18, display:'grid', gap:12}}>
        {data.items?.map((it:any, i:number)=>(
          <div key={i} style={{border:'1px solid rgba(255,255,255,.12)', borderRadius:12, padding:12}}>
            <div style={{fontWeight:700, display:'flex', alignItems:'center', gap:8}}>
              <span>{it.product}</span>
              <span style={{fontSize:12, opacity:.7}}>[{String(it.type).toUpperCase()}]</span>
            </div>
            <div style={{opacity:.85, marginTop:6}}>{it.summary}</div>
          </div>
        ))}
      </div>
      <div style={{fontSize:11, opacity:.7, marginTop:24}}>注：汇总公开来源，仅用于学习研究。</div>
    </div>
  );
}


⸻

四、产品历史页：查看某一产品的历次更新

新建 app/history/[product]/page.tsx

这里为了少写后端，直接：先取 /api/dates，再逐日请求 /api/brief/[date]，在客户端聚合。数据天数不大时完全可用；以后你需要更高性能，我再给你做一个服务端聚合接口。

'use client';
import { useEffect, useState } from 'react';

type Item = { product:string; type:string; summary:string; date?:string };

export default function ProductHistory({ params }: { params: { product: string } }){
  const product = decodeURIComponent(params.product);
  const [loading, setLoading] = useState(true);
  const [items, setItems] = useState<Item[]>([]);

  useEffect(()=>{
    (async ()=>{
      setLoading(true);
      const datesRes = await fetch('/api/dates').then(r=>r.json());
      const dates: string[] = datesRes.dates || [];
      const list: Item[] = [];
      // 逐日抓取（可并发）
      await Promise.all(dates.map(async (d)=>{
        const data = await fetch(`/api/brief/${d}`).then(r=>r.json());
        (data.items||[]).forEach((it:any)=>{
          if (it.product === product) list.push({ ...it, date: d });
        });
      }));
      setItems(list);
      setLoading(false);
    })();
  }, [product]);

  return (
    <div style={{maxWidth:900, margin:'40px auto', padding:'0 16px'}}>
      <div style={{display:'flex', justifyContent:'space-between', alignItems:'center'}}>
        <h1 style={{margin:0}}>{product} · 历史更新</h1>
        <a href="/archive" style={{opacity:.8}}>归档</a>
      </div>
      {loading ? <div style={{padding:20}}>加载中…</div> : (
        items.length === 0 ? <div style={{opacity:.7, marginTop:12}}>暂无记录</div> : (
          <div style={{display:'grid', gap:12, marginTop:14}}>
            {items.map((it, i)=>(
              <a key={i} href={`/brief/${it.date}`} style={{border:'1px solid rgba(255,255,255,.12)', padding:12, borderRadius:12, textDecoration:'none', color:'inherit'}}>
                <div style={{display:'flex', justifyContent:'space-between'}}>
                  <div style={{fontWeight:700}}>[{String(it.type).toUpperCase()}] {it.summary}</div>
                  <div style={{opacity:.7, fontSize:12}}>{it.date}</div>
                </div>
              </a>
            ))}
          </div>
        )
      )}
      <div style={{fontSize:11, opacity:.7, marginTop:24}}>注：汇总公开来源，仅用于学习研究。</div>
    </div>
  );
}

入口：你可以在首页的筛选器里，为每个产品名加一个「历史」链接：/history/OpenAI、/history/Anthropic……（中文名记得 encodeURIComponent）。

⸻

五、可选的小增强
	•	在首页筛选器里，把产品名做成可点击，直接跳到它的历史页：

<a className="tag" href={`/history/${encodeURIComponent(p)}`}>历史</a>


	•	如果你担心客户端多次请求，可以之后再加一个 /api/history?product=OpenAI 的服务端聚合接口（我也可以直接给你写）。

⸻

六、环境变量再确认（完整）

OPENAI_API_KEY
OPENAI_API_BASE_URL = https://openai.weavex.tech/v1
KV_REST_API_URL
KV_REST_API_TOKEN
MODEL = gpt-4o-mini   # 可选


